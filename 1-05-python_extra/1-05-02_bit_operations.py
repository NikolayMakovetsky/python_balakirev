# На этом занятии речь пойдет о битовых операциях над целыми числами

print("""
============Битовые операции=============
Полная форма | Краткая форма | Приоритет
=============|===============|===========
~a           |               | 3 (НЕ) 
a = a & b    | a &= b        | 2 (И)
a = a | b    | a |= b        | 1 (ИЛИ)
a = a ^ b    | a ^= b        | 1 (XOR)
=========================================
""")

print("------------------НЕ----------------")
# x | НЕ
# --|---
# 0 | 1
# 1 | 0

a = 121
print(f"{a = }", bin(a))  # bin возвращает битовое (двоичное) представление числа

def invert(x):
    """Как кажется должна была бы выглядеть инверсия"""
    s = str(x).split('b')
    s = s[1]
    res = s.replace('1', '?').replace('0', '1').replace('?', '0')
    return res

print(f"{a = }", f"{invert(bin(a)) = }", "//ПО ИДЕЕ ДОЛЖНО БЫТЬ ТАК")

print(f"{~a = }", bin(~a), "//НО ПОЧЕМУ ТАК?") #  оператор ~ (тильда) инвертирует биты числа

print("""
Из-за внутреннего представления отрицательных чисел ~a = -(a+1)
Внутр формат 32-х битных отрицательных чисел устроен так, что для смены знака нужно
все биты заменить на противоположные ("обратить") и прибавить 1
""")

b = 60
print(f"{b = }, {bin(b) = }, {~b = }, {bin(~b) = }, {~~b = }, {bin(~~b) = }")

print("----------------И------------------")
# x1 | x2 | И
# ---|----|---
# 0  | 0  | 0
# 0  | 1  | 0
# 1  | 0  | 0
# 1  | 1  | 1

flags = 5
mask = 6

res = flags & mask

print(f"{flags = }", bin(flags))
print(f"{mask = }", bin(mask))
print(f"{res = }", bin(res))
# включенным остался только 2-й бит, где flags & mask дали результат 1
# Биты в байте нумеруются справа налево от 0 до 7

print("----выключение битов числа----см.тему 'Дополнение двойки'")
flags = 13
print(f"{flags = }", bin(flags))

mask = 5
print(f"{mask = }", bin(mask))
print(f"{~mask = }", bin(~mask))

res = flags & (~mask) # flags &= ~mask
print(f"{flags & ~mask = }", bin(flags & ~mask))


print("----------------ИЛИ------------------")
# x1 | x2 | ИЛИ
# ===|====|===
# 0  | 0  | 0
# 0  | 1  | 1
# 1  | 0  | 1
# 1  | 1  | 1


flags = 8
mask = 5
res = flags | mask
print(f"{flags = }", bin(flags))
print(f"{mask = }", bin(mask))
print(f"{res = }", bin(res))

print("----------------исключающее ИЛИ (XOR)------------------")
# x1 | x2 | XOR
# ===|====|====
# 0  | 0  | 0
# 0  | 1  | 1
# 1  | 0  | 1
# 1  | 1  | 0


flags = 9
mask = 7
res = flags ^ mask
print(f"{flags = }", bin(flags)) 
print(f"{mask = }", bin(mask)) 
print(f"{res = }", bin(res)) 


print("--------------Операторы смещения бит--------------")
# Операции смещения бит влево и вправо
# выполняют целочисленное умножение и деление кратное двум.
# Причем эти операции умножения и деления работают значительно быстрее,
# чем традиционные арифметические операции умножения и деления.

print("---смещение вправо (на один бит)----эквивалентно делению на 2 без остатка")
x = 160
print(x, bin(x), "|", x >> 1, bin(x >> 1), "|", x >> 2, bin(x >> 2))
y = 50
print(y, bin(y), "|", y >> 1, bin(y >> 1), "|", y >> 2, bin(y >> 2))

print("\n---смещение влево (на один бит)----эквивалентно утножению на 2")
x = 160
print(x, bin(x), "|", x << 1, bin(x << 1), "|", x << 2, bin(x << 2))
y = 50
print(y, bin(y), "|", y << 1, bin(y << 1), "|", y << 2, bin(y << 2))