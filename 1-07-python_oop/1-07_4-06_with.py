# В целом менеджер контекста – это класс,
# в котором реализованы два магических метода: __enter__() и __exit__()

# Когда происходит создание менеджера контекста с помощью оператора with,
# то автоматически вызывается метод класса __enter__

# А когда менеджер контекста завершает свою работу
# (программа внутри него выполнилась или произошло исключение),
# то вызывается метод __exit__

print("\n---СИНТАКСИС вызова менеджера контекста следующий:")

# with <менеджер контекста> as <переменная>:
#       список конструкций языка Python

# «переменная» - это ссылка на экземпляр менеджера контекста,
# через которую, мы потом с ним можем работать.
# При необходимости ее можно опустить и записать все вот в таком виде:

# with <менеджер контекста>:
#       список конструкций языка Python


print("\n---Давайте создадим свой класс менеджера")
# Если программа в теле менеджера приводит к исключению (ошибке),
# то список должен оставаться прежним (без изменений)

# Мы здесь в приватном свойстве сохраняем ссылку на вектор,
# который следует «защитить».
# Далее, в методе enter создаем копию этого вектора и возвращаем его.
# То есть, переменная dv будет ссылаться на эту копию и
# обработка внутри менеджера будет происходить с элементами этой копии,
# а не исходным вектором.
# Затем, в методе exit мы проверяем: если исключений не произошло,
# то заменяем все элементы вектора __v на преобразованные __temp.
# В результате, при выходе из менеджера, мы получим измененный вектор v1.
# Если же было какое-либо исключение,
# то запись новых данных выполняться не будет и у нас останется прежний вектор v1.


class DefenerVector: # defener = защитник
    def __init__(self, v):
        self.__v = v    # в приватном свойстве сохраняем ссылку на вектор,
                        # который следует «защитить»
 
    def __enter__(self):
        self.__temp = self.__v[:]  # делаем копию вектора v
        return self.__temp
 
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is None: # если ошибок не произошло
            self.__v[:] = self.__temp # __v[:] ПОЧЕМУ ТАК НАПИСАНО ?
            print("В менеджере контекста ОШИБОК НЕ ПРОИЗОШЛО")
        else:
            print("В менеджере контекста ПРОИЗОШЛА ОШИБКА")
        return False

# Метод __exit__ у нас возвращает значение False,
# что означает обработку исключения (если оно произошло) вышестоящим блоком.
# Обычно именно так и делают,
# чтобы не скрывать возможные ошибки и в обработчике верхнего уровня
# реагировать должным образом на ошибочные ситуации.
# Кстати, оператор return можно вовсе опустить,
# тогда метод exit возвратит None, а оно интерпретируется как False.
# Так что, часто его не пишут.


v1 = [1, 2, 3]
v2 = [1, 2]
print(v1)
with DefenerVector(v1) as dv:
    # 1/0
    for i in range(len(dv)-1):
        dv[i] += v2[i]
 
print(v1)


print("\n---Вложенные менеджеры контекстов")
# Работает все очевидным образом.
# Сначала завершается (отрабатывает) вложенный менеджер,
# а затем, внешний (первый).
# Во всем остальном логика работы такого вложения сохраняется.

try:
    with open("myfile.txt") as fin:
        with open("out.txt", "w") as fout:
            for line in fin:
                fout.write(line)
except Exception as e:
    print(e)