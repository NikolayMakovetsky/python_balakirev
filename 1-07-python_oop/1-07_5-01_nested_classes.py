# Вложенные классы

#  В двух словах, это когда один класс объявлен внутри другого

print("\n---Разрешение конфликты имен внутри класса")

# На мой взгляд, хороший пример использования вложенных классов – это
# описание моделей во фреймворке Django.
# Если вы не знаете, что это такое, то не беспокойтесь,
# нам нужна будет только суть вложений.
# Итак, там часто можно встретить определения вида:

class Women:
    title = 'объект класса для поля title' # в Django вместо строк ссылки на
    photo = 'объект класса для поля photo' # определенные классы
    # Причем, атрибуты title и photo – это поля в таблице БД,
    # с которой впоследствии идет работа
    ordering = 'объект класса для поля ordering'
    
    # атрибут ordering и там, и там, и все работает
    # класс Мета позволяет разрешать конфликты имен такого типа
    class Meta:
        ordering = ['id']
    # В Django с помощью такого класса Meta определяют
    # некие вспомогательные параметры.
    # В частности, параметр ordering определяет сортировку по полю id
    # записей в таблице БД

print(Women.ordering)
print(Women.Meta.ordering)

w = Women()
print(w.ordering)
print(w.Meta.ordering)

print(w.__dict__)


print("\n---Meta - еще один атрибут (пространство имен) в классе Women")
# Но обратите внимание, объект класса Meta при этом не создается.
# Здесь Meta – это, по сути, еще один атрибут (пространство имен)
# в классе Women и мы к нему обращаемся через w как к атрибуту класса,
# не более того!!!

class Women:
    title = 'объект класса для поля title'
    photo = 'объект класса для поля photo'
    ordering = 'объект класса для поля ordering'
 
    def __init__(self, user, psw): # Добавили конструктор
        self._user = user
        self._psw = psw
 
    class Meta:
        ordering = ['id']


w = Women('root', '12345')
print(w.__dict__)


print("\n---")
# Теперь, при создании объекта класса Women будут автоматически
# создаваться два объекта: класса Women и класса Meta
# с соответствующими локальными свойствами

class Women:
    title = 'объект класса для поля title'
    photo = 'объект класса для поля photo'
    ordering = 'объект класса для поля ordering'
 
    def __init__(self, user, psw):
        self._user = user
        self._psw = psw
        self.meta = self.Meta(user + '@' + psw) # Добавили атрибут
 
    class Meta:
        ordering = ['id']
 
        def __init__(self, access): # добавили конструктор
            self._access = access

w = Women('root', '12345')
print(w.__dict__)
print(w.meta.__dict__)

# Обратите внимание,
# мы не можем из класса Meta или из его объектов обращаться
# к атрибутам класса Women.
# Это совершенно изолированное пространство имен от внешнего класса.
# Мало того, непосредственно во вложенном классе
# мы даже не можем явно указывать класс Women

# Обычно, вложенные классы содержат изолированный код,
# который доступен только из внешнего класса.
# Именно так следует проектировать программы
# при использовании вложенных классов


