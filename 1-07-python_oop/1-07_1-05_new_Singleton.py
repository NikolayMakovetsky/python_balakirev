import gc # управление сборщиком мусора
import sys

# На этом занятии мы познакомимся с еще одним магическим методом __new__,
# который вызывается непосредственно перед созданием объекта класса.

# Обязательный параметр cls – это ссылка на текущий класс Point,
# а затем, указываются коллекции из фактических и формальных параметров,
# которые может принимать данная функция.
# Это стандартное определение метода __new__ в классах.

print("\n---В данном примере объект не создастся!!!")

class Point:
    def __new__(cls, *args, **kwargs):
        print("вызов __new__ для " + str(cls))
 
    def __init__(self, x=0, y=0):
        print("вызов __init__ для " + str(self))
        self.x = x
        self.y = y

pt = Point(1, 2)
print(pt)

print("\n---метод __new__ должен возвращать адрес нового созданного объекта!!!")

class Point:
    def __new__(cls, *args, **kwargs):
        print("вызов __new__ для " + str(cls))
        return super().__new__(cls) # вызываем метод __new__ базового класса
# начиная с версии Python 3,
# все классы автоматически и неявно наследуются от базового класса object
 
# Если метод __new__ не прописывать в классе Point,
# то будет автоматически запускаться версия базового класса.
# То есть, этот метод всегда вызывается при создании нового объекта.

# В классе object уже существует программный код, общий для всех классов языка Python.

    def __init__(self, x=0, y=0):
        print("вызов __init__ для " + str(self))
        self.x = x
        self.y = y

pt = Point(1, 2) # аргументы 1 и 2 передаются и в метод __new__ и в метод __init__
print(pt)


print("\n---Пример паттерна Singleton (учебный)")
# Предположим, что мы разрабатываем класс для работы с БД.
# В частности, через него можно будет подключаться к СУБД,
# читать и записывать информацию, закрывать соединение.

# Далее мы полагаем, что в программе должен существовать только один экземпляр
# этого класса в каждый момент ее работы.
# То есть, одновременно два объекта класса DataBase быть не должно.
# Чтобы это обеспечить и гарантировать, как раз и используется паттерн Singleton.
# Реализуем его для класса DataBase.

class DataBase:
    __instance = None # атрибут будет хранить ссылку на экземпляр этого класса
                      # Если экземпляра нет, то атрибут будет принимать значение None.

    def __new__(cls, *args, **kwargs):
        if cls.__instance is None: # cls – ссылка на текущий класс
            cls.__instance = super().__new__(cls)
 
        return cls.__instance # Если создается второй экземпляр класса,
                              # то возвращай ссылку на уже существующий

    def __init__(self, user, psw, port):
        self.user = user
        self.psw = psw
        self.port = port
    

    def __del__(self):
        # DataBase.__instance = None # Обнуляем __instance чтобы освободить место
                                   # для ссылки на новый экземпляр
        print("Вызван метод del: "+ str(self))


    @classmethod
    def get_id(cls):
        return id(cls.__instance)
    
    @classmethod
    def CloseDb(cls):
        cls.__instance = None    

    def connect(self):
        print(f"соединение с БД: {self.user}, {self.psw}, {self.port}")
 
    def close(self):
        print("закрытие соединения с БД")
 
    def read(self):
        return "данные из БД"
 
    def write(self, data):
        print(f"запись в БД {data}")

print("\n---В строке 'db2 =' был вызван __init__ с новым набором аргументов")

# Конечно, мы можем здесь поставить «костыль» (как говорят в программисты)
# и дополнительно в классе прописать флаговый атрибут, например:
# __is_exist = False специально для метода __init__,
# чтобы не выполнять его если объект уже создан.
# Но это слишком уж костыльно получается.
# Правильнее было бы здесь переопределить магический метод __call__,
# о котором мы еще будем говорить.


db = DataBase('root', '1234', 20)
db2 = DataBase('root2', '5678', 60)
print(f"{id(db) = }")
print(f"{id(db2) = }")
print(f"{DataBase.get_id() = }")

print("\n---Раз мы не хотим создавать 2-й объект свойства должны остаться 'root', '1234', 20")
db.connect()    # root2, 5678, 60
db2.connect()   # root2, 5678, 60
DataBase.CloseDb()
del db  # разрыв связи между ссылкой и объектом
del db2 # разрыв связи между ссылкой и объектом


# print(f"ПОСЛЕ ПРИНУДИТЕЛЬНОГО ВЫПОЛНЕНИЯ __del__ ЭКЗЕМПЛЯР ЕЩЕ СУЩЕСТВУЕТ: {db.connect()}")
# print(sys.getrefcount(db))


# print(gc.get_referrers(db))
# print(dir(db))

# gc.collect()
# db, db2 = 0, 0
# КАК одновременно выполнить __del__ и del statement ???
# db.connect() # NameError: name 'db' is not defined


print("\n---После удаления всех экземпляров, создаем новый экземпляр")
# Как видим id экземпляра отличается от созданного ранее
# db = DataBase('root', '1234', 20)
# print(f"{id(db) = }")
# db.connect()


print("\n---Работа инструкции del")
# The del statement
# Несмотря на свое название, инструкция del не удаляет объекты в буквальном смысле,
# она лишь открепляет ссылки, разрывая связь между именем и объектом.
# Удаление объекта произойдет как следствие работы сборщика мусора
# в отношении объектов, на которые больше не ссылается ни один другой объект.

# del variable - удаление переменной,
# del obj.attr - удаление атрибута,
# del data[k] - удаление элемента по индексу или ключу в случае словаря,
# del data[i:j] - удаление элементов по срезу.

